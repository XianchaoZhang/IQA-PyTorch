<!--
# Codebase Designs and Conventions
 -->
# 代码库设计和约定

<!--
#### Contents
 -->
#### 内容

<!--
1. [Overall Framework](#Overall-Framework)
1. [Features](#Features)
    1. [Dynamic Instantiation](#Dynamic-Instantiation)
1. [Conventions](#Conventions)
 -->
1. [总体框架](#Overall-Framework)
1. [功能](#功能)
    1. [动态实例化](#Dynamic-Instantiation)
1. [约定](#约定)

<!--
## Overall Framework
 -->
## 总体框架

<!--
The `PyIQA` framework can be divided into the following parts: data, model, options/configs and training process. <br>
When we modify or add a new method, we often modify/add it from the above aspects. <br>
The figure below shows the overall framework.
 -->
`PyIQA` 框架可以分为以下部分：数据、模型、选项/配置和训练过程。当我们修改或添加新的方法时，往往会从以上几个方面进行修改/添加。下图为整体框架。

<!--
![overall_structure](../assets/overall_structure.png)
 -->
![总体结构](./assets/overall_structure.png)

<!--
## Features
 -->
## 功能

<!--
### Dynamic Instantiation
 -->
### 动态实例化

<!--
When we add a new class or function, it can be used directly in the configuration file. The program will automatically scan, find and instantiate according to the class name or function name in the configuration file. This process is called dynamic instantiation.
 -->
当我们添加新的类或函数时，可以直接在配置文件中使用。程序会根据配置文件中的类名或函数名自动扫描、查找并实例化。这个过程称为动态实例化。

<!--
Specifically, we implement it through `importlib` and `getattr`. Taking the data module as example, we follow the below steps in [`data/__init__.py`](../pyiqa/data/__init__.py):
 -->
具体来说，我们通过 `importlib` 和 `getattr` 来实现。以数据模块为例，我们在 [`data/__init__.py`](../pyiqa/data/__init__.py) 中执行以下步骤：

<!--
1. Scan all the files under the data folder with '_dataset' in file names
1. Import the classes or functions in these files through `importlib`
1. Instantiate through `getattr` according to the name in the configuration file
 -->
1. 扫描 data 文件夹下所有文件名含有 '_dataset' 的文件
1. 通过 `importlib` 导入这些文件中的类或函数
1. 根据配置文件中的名称通过 `getattr` 实例化

```python
# automatically scan and import dataset modules
# scan all the files under the data folder with '_dataset' in file names
data_folder = osp.dirname(osp.abspath(__file__))
dataset_filenames = [
    osp.splitext(osp.basename(v))[0] for v in scandir(data_folder)
    if v.endswith('_dataset.py')
]
# import all the dataset modules
_dataset_modules = [
    importlib.import_module(f'basicsr.data.{file_name}')
    for file_name in dataset_filenames
]

...

# dynamic instantiation
for module in _dataset_modules:
    dataset_cls = getattr(module, dataset_type, None)
    if dataset_cls is not None:
        break
```

<!--
We use the similar techniques for the following modules. Pay attention to the conventions of file suffix when using them:
 -->
我们对以下模块使用类似的技术。使用时要注意文件后缀的约定：

| Module         | File Suffix     | Example        |
| :------------- | :----------:    | :----------:   |
| Data           | `_dataset.py`   | `data/general_nr_dataset.py` |
| Model          | `_model.py`     | `pyiqa/models/general_iqa_model.py` |
| Archs          | `_arch.py`      | `pyiqa/archs/clipiqa_arch.py`|

<!--
Note:
 -->
注意：

<!--
1. The above file suffixes are only used when necessary. Other file names should avoid using the above suffixes.
1. Note that the class name or function name cannot be repeated.
 -->
1. 以上文件后缀仅在必要时使用。其他文件名应避免使用上述后缀。
1. 注意类名或函数名不能重复。

<!--
In addition, we also use `importlib` and `getattr` for `losses` and `metrics`. However, for losses and metrics, the number of files is smaller and the changes are less. So, we do not use the strategy of scanning files.
For these two modules, after adding new classes or functions, we need to add the corresponding class or function names to `__init__.py`.
 -->
此外，我们还使用 `importlib` 和 `getattr` 来表示 `losses` 和 `metrics`。然而，对于损失和指标来说，文件数量更小，变化也更少。所以，我们不采用扫描文件的策略。对于这两个模块，添加新的类或函数后，我们需要在 `__init__.py` 中添加相应的类或函数名。

| Module         | Path     | Modify `__init__.py`        |
| :------------- | :----------:    | :----------:   |
| Losses           | `pyiqa/losses`   | [`pyiqa/losses/__init__.py`](../basicsr/models/losses/__init__.py) |
| Metrics          | `pyiqa/metrics`     | [`pyiqa/metrics/__init__.py`](../basicsr/metrics/__init__.py)|

<!--
## Conventions
 -->
## 约定

<!--
1. In dynamic instantiation, there are requirements to the file suffix in the following module. Otherwise, automatic instantiation cannot be achieved.
 -->
1. 动态实例化时，对以下模块的文件后缀有要求。否则无法实现自动实例化。

    | Module         | File Suffix     | Example        |
    | :------------- | :----------:    | :----------:   |
    | Data           | `_dataset.py`   | `data/general_nr_dataset.py` |
    | Model          | `_model.py`     | `pyiqa/models/general_iqa_model.py` |
    | Archs          | `_arch.py`      | `pyiqa/archs/clipiqa_arch.py`|

<!-- FIXME
1. When logging, the loss items are recommended to start with `l_`, so that all these loss items will be grouped together in tensorboard. For example, in [basicsr/models/srgan_model.py](../basicsr/models/srgan_model.py), we use `l_g_pix`, `l_g_percep`, `l_g_gan`, etc for loss items. In [basicsr/utils/logger.py](../basicsr/utils/logger.py), these items will be grouped together:
 -->
1. 记录时，建议损失项以 `l_` 开头，这样所有这些损失项将在 tensorboard 中分组在一起。例如，在 [pyiqa/models/srgan_model.py](../pyiqa/models/srgan_model.py) 中，我们使用 `l_g_pix`、`l_g_percep`、`l_g_gan` 等作为损失项。在 [pyiqa/utils/logger.py](../pyiqa/utils/logger.py) 中，这些项将被分组在一起：

    ```python
    if k.startswith('l_'):
        self.tb_logger.add_scalar(f'losses/{k}', v, current_iter)
    else:
        self.tb_logger.add_scalar(k, v, current_iter)
    ```
